name: "\U0001F510 Auto Key Management & Validation"

on:
  schedule:
    - cron: "0 0 * * 0" # Every Sunday at midnight UTC
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - "src/config/**"
      - "src/agents/**"

jobs:
  validate-keys:
    name: "Validate All AI Keys"
    runs-on: ubuntu-latest
    outputs:
      openai_status: ${{ steps.check.outputs.openai }}
      anthropic_status: ${{ steps.check.outputs.anthropic }}
      perplexity_status: ${{ steps.check.outputs.perplexity }}
      google_status: ${{ steps.check.outputs.google }}
      moonshot_status: ${{ steps.check.outputs.moonshot }}
      slack_status: ${{ steps.check.outputs.slack }}
      render_status: ${{ steps.check.outputs.render }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install dependencies
        run: npm ci

      - name: Validate AI Keys
        id: check
        env:
          OPENAI_KEY: ${{ secrets.OPENAI_BSM_KEY }}
          ANTHROPIC_KEY: ${{ secrets.ANTHROPIC_KEY }}
          PERPLEXITY_KEY: ${{ secrets.PERPLEXITY_KEY }}
          GOOGLE_KEY: ${{ secrets.GOOGLE_AI_KEY }}
          MOONSHOT_KEY: ${{ secrets.MOONSHOT_API_KEY }}
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          RENDER_HOOK: ${{ secrets.RENDER_DEPLOY_HOOK }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const https = require('https');
          const http = require('http');

          function requestStatus({ hostname, path, key, method = 'GET', headers = {}, protocol = 'https' }) {
            return new Promise((resolve) => {
              if (!key) {
                resolve(false);
                return;
              }

              const lib = protocol === 'http' ? http : https;
              const req = lib.request(
                {
                  hostname,
                  path,
                  method,
                  timeout: 10000,
                  headers: {
                    Authorization: `Bearer ${key}`,
                    ...headers
                  }
                },
                (res) => {
                  resolve(res.statusCode >= 200 && res.statusCode < 400);
                }
              );

              req.on('timeout', () => {
                req.destroy(new Error('timeout'));
              });
              req.on('error', () => resolve(false));
              req.end();
            });
          }

          function checkUrl(urlStr) {
            return new Promise((resolve) => {
              if (!urlStr) {
                resolve(false);
                return;
              }
              try {
                const url = new URL(urlStr);
                const lib = url.protocol === 'http:' ? http : https;
                const req = lib.request(
                  {
                    hostname: url.hostname,
                    path: url.pathname + url.search,
                    port: url.port || undefined,
                    method: 'POST',
                    timeout: 10000,
                    headers: { 'Content-Type': 'application/json' }
                  },
                  (res) => {
                    resolve(res.statusCode >= 200 && res.statusCode < 500);
                  }
                );
                req.on('timeout', () => req.destroy(new Error('timeout')));
                req.on('error', () => resolve(false));
                req.write('{}');
                req.end();
              } catch {
                resolve(false);
              }
            });
          }

          const validators = {
            openai: (key) =>
              requestStatus({
                hostname: 'api.openai.com',
                path: '/v1/models',
                key
              }),

            perplexity: (key) =>
              requestStatus({
                hostname: 'api.perplexity.ai',
                path: '/models',
                key
              }),

            moonshot: (key) =>
              requestStatus({
                hostname: 'api.moonshot.cn',
                path: '/v1/models',
                key
              }),

            anthropic: async (key) =>
              Boolean(key && /^sk-ant-[A-Za-z0-9_-]{20,}$/.test(key)),

            google: async (key) =>
              Boolean(key && /^AIza[A-Za-z0-9_-]{20,}$/.test(key)),

            slack: (_key) => checkUrl(process.env.SLACK_WEBHOOK),
            render: (_key) => checkUrl(process.env.RENDER_HOOK)
          };

          async function validateAll() {
            const results = {
              openai: false,
              anthropic: false,
              perplexity: false,
              google: false,
              moonshot: false,
              slack: false,
              render: false
            };

            const inputKeys = {
              openai: process.env.OPENAI_KEY,
              anthropic: process.env.ANTHROPIC_KEY,
              perplexity: process.env.PERPLEXITY_KEY,
              google: process.env.GOOGLE_KEY,
              moonshot: process.env.MOONSHOT_KEY,
              slack: process.env.SLACK_WEBHOOK,
              render: process.env.RENDER_HOOK
            };

            for (const provider of Object.keys(results)) {
              if (!inputKeys[provider]) {
                console.log(`${provider}: \u274C (not configured)`);
                continue;
              }

              results[provider] = await validators[provider](inputKeys[provider]);
              console.log(`${provider}: ${results[provider] ? '\u2705' : '\u274C'}`);
            }

            for (const key of Object.keys(results)) {
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `${key}=${results[key]}\n`);
            }

            fs.writeFileSync(
              'key-report.json',
              JSON.stringify(
                {
                  timestamp: new Date().toISOString(),
                  results,
                  summary: {
                    total: Object.keys(results).length,
                    active: Object.values(results).filter(Boolean).length,
                    inactive: Object.values(results).filter((v) => !v).length
                  }
                },
                null,
                2
              )
            );

            const configured = Object.entries(inputKeys).filter(([, v]) => v);
            const failed = configured.filter(([name]) => !results[name]).map(([name]) => name);

            if (failed.length > 0) {
              console.error(`\n\u274C Failed keys: ${failed.join(', ')}`);
              process.exit(1);
            }

            console.log(`\n\u2705 All configured keys validated (${configured.length}/${Object.keys(results).length})`);
          }

          validateAll().catch((error) => {
            console.error('Validation script crashed:', error.message);
            process.exit(1);
          });
          EOF

      - name: Upload validation report
        uses: actions/upload-artifact@v4
        with:
          name: key-validation-report
          path: key-report.json

  update-dashboard:
    name: "Update Dashboard"
    needs: validate-keys
    runs-on: ubuntu-latest
    if: always()
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Key Status Dashboard
        run: |
          mkdir -p docs/status

          cat > docs/status/ai-keys.json << DASHEOF
          {
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "status": {
              "openai": "${{ needs.validate-keys.outputs.openai_status }}",
              "anthropic": "${{ needs.validate-keys.outputs.anthropic_status }}",
              "perplexity": "${{ needs.validate-keys.outputs.perplexity_status }}",
              "google": "${{ needs.validate-keys.outputs.google_status }}",
              "moonshot": "${{ needs.validate-keys.outputs.moonshot_status }}",
              "slack": "${{ needs.validate-keys.outputs.slack_status }}",
              "render": "${{ needs.validate-keys.outputs.render_status }}"
            },
            "ui": {
              "openai": "${{ needs.validate-keys.outputs.openai_status == 'true' && 'âœ… GPT-4 Ready' || 'ðŸ”´ GPT-4 Offline' }}",
              "anthropic": "${{ needs.validate-keys.outputs.anthropic_status == 'true' && 'âœ… Claude Ready' || 'ðŸ”´ Claude Offline' }}",
              "perplexity": "${{ needs.validate-keys.outputs.perplexity_status == 'true' && 'âœ… Perplexity Ready' || 'ðŸ”´ Perplexity Offline' }}",
              "google": "${{ needs.validate-keys.outputs.google_status == 'true' && 'âœ… Gemini Ready' || 'ðŸ”´ Gemini Offline' }}",
              "moonshot": "${{ needs.validate-keys.outputs.moonshot_status == 'true' && 'âœ… Kimi Ready' || 'ðŸ”´ Kimi Offline' }}",
              "slack": "${{ needs.validate-keys.outputs.slack_status == 'true' && 'âœ… Slack Connected' || 'ðŸ”´ Slack Offline' }}",
              "render": "${{ needs.validate-keys.outputs.render_status == 'true' && 'âœ… Render Hook Ready' || 'ðŸ”´ Render Offline' }}"
            }
          }
          DASHEOF

          git config user.name "BSU Key Manager"
          git config user.email "keys@corehub.nexus"

          git add docs/status/ai-keys.json
          git diff --cached --quiet && echo "No changes" && exit 0

          git commit -m "auto-update: AI Key Status [$(date +%Y-%m-%d)]"
          git push

  alert-failure:
    name: "Alert on Failure"
    needs: validate-keys
    runs-on: ubuntu-latest
    if: failure()
    steps:
      - name: Send Slack Alert
        if: ${{ secrets.SLACK_WEBHOOK_URL != '' }}
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "BSU Nexus: AI Key Validation Failed!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*AI Key Validation Failed*\n\nâ€¢ OpenAI: ${{ needs.validate-keys.outputs.openai_status == 'true' && 'âœ…' || 'âŒ' }}\nâ€¢ Anthropic: ${{ needs.validate-keys.outputs.anthropic_status == 'true' && 'âœ…' || 'âŒ' }}\nâ€¢ Perplexity: ${{ needs.validate-keys.outputs.perplexity_status == 'true' && 'âœ…' || 'âŒ' }}\nâ€¢ Google: ${{ needs.validate-keys.outputs.google_status == 'true' && 'âœ…' || 'âŒ' }}\nâ€¢ Moonshot: ${{ needs.validate-keys.outputs.moonshot_status == 'true' && 'âœ…' || 'âŒ' }}\nâ€¢ Slack: ${{ needs.validate-keys.outputs.slack_status == 'true' && 'âœ…' || 'âŒ' }}\nâ€¢ Render: ${{ needs.validate-keys.outputs.render_status == 'true' && 'âœ…' || 'âŒ' }}\n\n<https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  deploy-if-valid:
    name: "Deploy with Valid Keys"
    needs: validate-keys
    runs-on: ubuntu-latest
    if: needs.validate-keys.result == 'success'
    steps:
      - name: Deploy to Production
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
        run: |
          if [ -z "$RENDER_API_KEY" ] || [ -z "$RENDER_SERVICE_ID" ]; then
            echo "Render API secrets not configured, skipping deploy"
            exit 0
          fi

          echo "Deploying with validated keys..."
          curl -fsS -X POST \
            -H "Authorization: Bearer $RENDER_API_KEY" \
            "https://api.render.com/v1/services/$RENDER_SERVICE_ID/deploys"

          echo "Deployment triggered successfully!"
